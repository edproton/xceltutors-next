generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  TUTOR
  STUDENT
  ADMIN
  MODERATOR
}

model ProviderAccount {
  id              Int       @id @default(autoincrement())
  provider        String    // "google", "discord", etc
  oauthProviderId String    // ID from the OAuth provider
  userId          Int
  email           String
  imageUrl        String?
  accessToken     String?
  refreshToken    String?
  expiresAt       DateTime?
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions        Session[]

  @@unique([provider, oauthProviderId])
}

model CredentialsProvider {
  id              Int       @id @default(autoincrement())
  userId          Int       @unique  // One credentials account per user
  email           String    @unique
  passwordHash    String
  
  // Security fields
  failedAttempts  Int       @default(0)
  lastFailedAt    DateTime?
  lockedUntil     DateTime?
  lastPasswordAt  DateTime  @default(now())
  passwordHistory Json?     // Array of previous password hashes
  
  // MFA fields
  mfaEnabled      Boolean   @default(false)
  mfaType         MFAType?
  mfaSecret       String?   // TOTP secret or phone number
  backupCodes     Json?     // Encrypted backup codes
  
  // Recovery fields
  resetToken      String?   @unique
  resetTokenExpiresAt DateTime?
  
  // Session management
  sessions        Session[]
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

enum MFAType {
  TOTP
  SMS
  EMAIL
}

// Update User model to include optional credentials
model User {
  id                Int                 @id @default(autoincrement())
  sessions          Session[]
  accounts          ProviderAccount[]   // OAuth providers
  credentials       CredentialsProvider? // Password-based auth
  image             String?
  name              String
  roles             Role[]
  
  hostedBookings    Booking[]          @relation("BookingHost")
  joinedBookings    Booking[]          @relation("BookingParticipants")
}

model Session {
  id                String             @id
  userId            Int
  expiresAt         DateTime
  authenticationType AuthenticationType // To explicitly track the type
  
  // One of these must be set based on authenticationType
  providerAccountId Int?
  credentialsId     Int?

  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  providerAccount   ProviderAccount?   @relation(fields: [providerAccountId], references: [id], onDelete: Cascade)
  credentials       CredentialsProvider? @relation(fields: [credentialsId], references: [id], onDelete: Cascade)

  @@index([providerAccountId])
  @@index([credentialsId])
}

enum AuthenticationType {
  OAUTH
  CREDENTIALS
}

enum BookingType {
  FREE_MEETING
  LESSON
}

enum BookingStatus {
  AWAITING_TUTOR_CONFIRMATION
  AWAITING_STUDENT_CONFIRMATION
  AWAITING_PAYMENT
  PAYMENT_FAILED
  SCHEDULED
  CANCELED
  COMPLETED
  REFUNDED
  AWAITING_REFUND
  REFUND_FAILED
}

enum RecurrencePattern {
  NONE // Default for free meetings or one-time bookings
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  CUSTOM
}

model Payment {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Stripe-specific fields
  sessionId       String? @unique
  paymentIntentId String? @unique
  chargeId        String?
  sessionUrl      String?

  // Payment metadata
  metadata Json? // Stores additional payment information as JSON

  // Booking relationship
  bookingId Int     @unique
  booking   Booking @relation(fields: [bookingId], references: [id])
}

model Booking {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime

  // Enum fields
  type   BookingType
  status BookingStatus

  // Host relationship
  hostId Int
  host   User @relation("BookingHost", fields: [hostId], references: [id])

  // Participants many-to-many relationship
  participants User[] @relation("BookingParticipants")

  // Recurring booking fields
  recurrence         RecurrencePattern @default(NONE)
  recurrenceEnd      DateTime?
  parentBookingId    Int?
  parentBooking      Booking?          @relation("ParentBooking", fields: [parentBookingId], references: [id])
  recurringInstances Booking[]         @relation("ParentBooking")

  // Payment relationship
  payment Payment?

  @@index([hostId])
}
